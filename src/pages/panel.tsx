import axios from 'axios'
import { _ } from 'gridjs-react'
import type { GetServerSideProps, NextPage } from 'next'
import Head from 'next/head'
import { FormEvent, useState } from 'react'
import { DateRange, Range } from 'react-date-range'
import { IoCalendarClearOutline } from 'react-icons/io5'
import { MdSegment } from 'react-icons/md'
import Select from 'react-select'
import makeAnimated from 'react-select/animated'
import { useTheme } from 'styled-components'
import Swal from 'sweetalert2'

import api from '@/services/api'
import getStatusClassName from '@/utils/getStatusClassName'
import { statusToId } from '@/utils/status'
import DonutChart from '@components/DonutChart'
import Filter from '@components/Filter'
import Input from '@components/Input'
import Rank from '@components/Rank'
import Table from '@components/Table'
import { Temporal } from '@js-temporal/polyfill'
import {
	Container,
	Main,
	FiltersContainer,
	DateButton,
} from '@styles/pages/Panel'

const products = [
	{ value: 'fgts', label: 'FGTS' },
	{ value: 'inss', label: 'INSS' },
]

const statuses = [
	{ value: 0, label: 'Em análise' },
	{ value: 1, label: 'Aguardando formalização' },
	{ value: 2, label: 'Em averbação' },
]

const periods = [
	{ value: 'mensal', label: 'Mensal' },
	{ value: 'semanal', label: 'Semanal' },
	{ value: 'anual', label: 'Anual' },
]

const animatedComponents = makeAnimated()

interface Props {
	data: GlobalInterfaces.PanelDataProps
	type?: string
}

const Panel: NextPage<Props> = (props) => {
	const now = new Date()

	const colors = useTheme().colors
	const [data, setData] = useState(props.data.tableData)
	const [analysisTotal, setAnalysisTotal] = useState(props.data.analysisTotal)
	const [date, setDate] = useState<Range[]>([
		{
			startDate: new Date(now.setMonth(now.getMonth() - 3)),
			endDate: new Date(),
			key: 'selection',
		},
	])

	const [dateRangeOpen, setDateRangeOpen] = useState(false)

	const donutSeries = data?.reduce(
		(prev, curr) => {
			const status = statusToId(curr.status)
			prev[status] += 1

			return prev
		},
		[0, 0, 0]
	)

	const donutFontSeries = data?.reduce(
		(prev, curr: GlobalInterfaces.ManagerData) => {
			const font = Object.keys(prev).indexOf(curr.font.toLocaleUpperCase())

			if (font >= 0) {
				prev[curr.font] += 1
			} else {
				prev[curr.font] = 1
			}

			return prev
		},
		{}
	)

	const tableConfig: GlobalInterfaces.TableProps<GlobalInterfaces.ManagerData> =
		{
			data,
			columns: [
				{
					name: 'Nome do cliente',
					id: 'clientName',
				},
				{
					name: 'Valor liberado',
					data: (row) =>
						Intl.NumberFormat('pt-BR', {
							currency: 'BRL',
							style: 'currency',
						}).format(row.value),
				},
				{
					name: 'Prazo',
					data: (row) =>
						Temporal.Instant.from(row.term).toLocaleString('pt-BR', {
							dateStyle: 'short',
						}),
				},
				{
					name: 'Banco',
					id: 'bank',
				},
				{
					name: 'Produto',
					id: 'product',
				},
				{
					name: 'Status',
					id: 'status',
					formatter: (cell) =>
						_(<div className={getStatusClassName(cell as string)}>{cell}</div>),
				},
				{
					name: 'Vendedor',
					id: 'seller',
				},
				{
					name: 'Data',
					data: (row) =>
						Temporal.Instant.from(row.date).toLocaleString('pt-BR', {
							dateStyle: 'short',
						}),
				},
			],
		}

	async function onFilterSubmit(e: FormEvent) {
		e.preventDefault()
		const filteredDate = date[0]

		if (!filteredDate.endDate || !filteredDate.startDate) {
			Swal.fire({
				icon: 'error',
				title: 'Intervalo de data',
				text: 'O intervalo de data não pode ser vazio!',
			})

			return console.log('Error')
		}

		const timeDiff = Math.abs(
			filteredDate.endDate.getTime() - filteredDate.startDate.getTime()
		)
		const diffDays = Math.ceil(timeDiff / (1000 * 3600 * 24))
		const diffMoths = diffDays / 30

		if (Number(diffMoths.toFixed(0)) > 3) {
			Swal.fire({
				icon: 'error',
				title: 'Data maior que 3 meses',
				text: 'O intervalo de data, tem que ser inferior ou igual a 3 meses.',
			})

			return console.log('Error')
		}

		try {
			const { data } = await api.get<GlobalInterfaces.PanelDataProps>(
				'/api/painel-data',
				{
					params: {
						type: props.type,
						startDate: filteredDate.startDate,
						endDate: filteredDate.endDate,
					},
				}
			)

			setData(data.tableData)
			setAnalysisTotal(data.analysisTotal)
		} catch (error) {
			Swal.fire({
				icon: 'error',
				title: 'Oops...',
				text: 'Houve um erro inesperado, contate o suporte!',
			})
		}
	}

	return (
		<Container>
			<Head>
				<title>CredFácil - Distribuição Fila</title>
				<meta name="description" content="Generated by create next app" />
				<link rel="icon" href="/favicon.ico" />
			</Head>

			{/* <Header /> */}

			<Main>
				<FiltersContainer>
					<Filter maxHeight={620} onFilterSubmit={onFilterSubmit}>
						<Input label="Período">
							<Select
								components={animatedComponents}
								name="periods"
								placeholder="Selecione um período..."
								options={periods}
							/>
						</Input>
						<Input label="Produtos">
							<Select
								isMulti
								components={animatedComponents}
								name="products"
								placeholder="Selecione um produto..."
								options={products}
							/>
						</Input>
						<Input label="Status">
							<Select
								isMulti
								components={animatedComponents}
								name="status"
								placeholder="Selecione um status..."
								options={statuses}
							/>
						</Input>

						<Input label="Data">
							<DateButton>
								<button onClick={() => setDateRangeOpen(!dateRangeOpen)}>
									<IoCalendarClearOutline />
									<span>
										{date[0].startDate
											? Temporal.PlainDate.from(
													date[0].startDate.toISOString().replace('Z', '')
											  ).toLocaleString('pt-BR', {
													dateStyle: 'short',
											  })
											: 'Data inicial'}
									</span>
								</button>
								<div className="line" />
								<button onClick={() => setDateRangeOpen(!dateRangeOpen)}>
									<span>
										{date[0].endDate
											? Temporal.PlainDate.from(
													date[0].endDate.toISOString().replace('Z', '')
											  ).toLocaleString('pt-BR', {
													dateStyle: 'short',
											  })
											: 'Data final'}
									</span>
								</button>
								{dateRangeOpen && (
									<>
										<div
											className="overflow"
											onClick={() => setDateRangeOpen(!dateRangeOpen)}
										/>
										<DateRange
											classNames={{
												calendarWrapper: 'calendar-wrapper',
											}}
											editableDateInputs={true}
											onChange={(item) => setDate([item.selection])}
											ranges={date}
										/>
									</>
								)}
							</DateButton>
						</Input>
					</Filter>

					<Rank>
						<header>
							<MdSegment color="#8B83BA" />
							<span>Geral</span>
						</header>
						<div className="donut-wrapper2">
							<div>
								<DonutChart
									width="150%"
									height={300}
									series={donutSeries}
									colors={[colors.red, colors.main, colors.tertiary]}
									labels={[
										'Encerrado/Recusa/Fora da política',
										'Finalizado/Confirmado/Pago',
										'Em análise/Aguardando formalização',
									]}
								/>
								<DonutChart
									width="125%"
									height={300}
									series={Object.values(donutFontSeries)}
									labels={Object.keys(donutFontSeries)}
								/>
							</div>

							<ul>
								<li>
									<b>Quantidade de propostas:</b> {data.length}
								</li>
								<li>
									<b>Valor em análise:</b> {analysisTotal}
								</li>
							</ul>
						</div>
					</Rank>
				</FiltersContainer>

				<Table
					headerDirection="row"
					pagination={{
						enabled: true,
					}}
					{...tableConfig}
				/>
			</Main>
		</Container>
	)
}

export const getServerSideProps: GetServerSideProps = async (context) => {
	const now = new Date()

	try {
		const { data } = await api.get<GlobalInterfaces.PanelDataProps>(
			'/api/painel-data',
			{
				params: {
					type: context.query.type,
					startDate: new Date(now.setMonth(now.getMonth() - 3)),
					endDate: new Date(),
				},
			}
		)

		return {
			props: {
				data,
				...context.query,
			},
		}
	} catch (error) {
		if (axios.isAxiosError(error)) {
			return {
				props: error.response?.data ?? {},
			}
		}

		return {
			props: {},
		}
	}
}

export default Panel
